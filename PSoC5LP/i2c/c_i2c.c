/*! @file
  @brief
  I2C class for Cypress PSoC5LP

  <pre>
  Copyright (C) 2018-2020 Kyushu Institute of Technology.
  Copyright (C) 2018-2020 Shimane IT Open-Innovation Center.

  This file is distributed under BSD 3-Clause License.

  (Usage)
  * Place 'I2C Master' device by PSoC Creator.
  * Add file 'c_i2c.c' to PSoC Creator.
  * Add below to main.c.
      #include "c_i2c.h"
      mrbc_init_class_i2c(0);	// needs to be after mrbc_init()


  (Note)
  * Only I2C master mode and only 1 device.
    Preparing to handle multiple instances, but can't use it in this version.

  (on Ruby)
    i2c = I2C.new()

    # write to device
    i2c.write( i2c_adrs_7, data1, data2,... )
    i2c.write( i2c_adrs_7, "string" )

    # read from device
    s = i2c.read( i2c_adrs_7, read_bytes, *params )
    s.getbyte(n)

    # convert byte array to uint16, int16 example.
    def to_uint16( b1, b2 )
      return (b1 << 8 | b2)
    end
    def to_int16( b1, b2 )
      return (b1 << 8 | b2) - ((b1 & 0x80) << 9)
    end

  (see)
    See the comments in each function header for more information.

  </pre>
*/


#include "vm_config.h"
#include <stdint.h>
#include <project.h>	// auto generated by PSoC Creator.

#include "value.h"
#include "alloc.h"
#include "static.h"
#include "symbol.h"
#include "class.h"
#include "c_string.h"
#include "c_array.h"
#include "console.h"


// convert pseudo identifier to real identifier.
#define I2CNAME_MSTR_NO_ERROR		I2C_1_MSTR_NO_ERROR
#define I2CNAME_ACK_DATA		I2C_1_ACK_DATA
#define I2CNAME_NAK_DATA		I2C_1_NAK_DATA
#define I2CNAME_MasterClearStatus	I2C_1_MasterClearStatus
#define I2CNAME_MasterReadByte		I2C_1_MasterReadByte
#define I2CNAME_MasterSendRestart	I2C_1_MasterSendRestart
#define I2CNAME_MasterSendStart		I2C_1_MasterSendStart
#define I2CNAME_MasterSendStop		I2C_1_MasterSendStop
#define I2CNAME_MasterStatus		I2C_1_MasterStatus
#define I2CNAME_MasterWriteByte		I2C_1_MasterWriteByte
#define I2CNAME_Start			I2C_1_Start


//================================================================
/*! Define I2C attribute structure.
*/
struct I2C_attr
{
  uint8_t state;	//!< none=-1, read=1, write=0
  uint8_t address;	//!< 7bit I2C address.
  uint8_t status;
};
enum {
  I2C_STATE_NONE = 0,
  I2C_STATE_READ1 = 0x02,
  I2C_STATE_READ2 = 0x03,
  I2C_STATE_WRITE = 0x04,
};


//================================================================
/*! I2C constructor
*/
static void c_i2c_new(struct VM *vm, mrb_value v[], int argc)
{
  *v = mrbc_instance_new(vm, v->cls, sizeof(struct I2C_attr));
  struct I2C_attr *attr = (struct I2C_attr *)v->instance->data;
  attr->state = I2C_STATE_NONE;
  attr->address = -1;
  attr->status = 0;
}


//================================================================
/*! I2C get status
*/
static void c_i2c_status(struct VM *vm, mrb_value v[], int argc)
{
  struct I2C_attr *attr = (struct I2C_attr *)v->instance->data;
  int status = I2CNAME_MasterStatus();
  attr->status = status;
  SET_INT_RETURN( status );
}


//================================================================
/*! I2C clear status
*/
static void c_i2c_clear_status(struct VM *vm, mrb_value v[], int argc)
{
  struct I2C_attr *attr = (struct I2C_attr *)v->instance->data;

  I2CNAME_MasterClearStatus();
  attr->state = I2C_STATE_NONE;
  attr->address = -1;
  attr->status = 0;
}


//================================================================
/*! I2C read

  (mruby usage)
  s = i2c.read( i2c_adrs_7, read_bytes, *params )
  s.getbyte(n)  # bytes

  i2c_adrs_7 = Fixnum
  read_byres = Fixnum
  *params    = Fixnum (option)

  (I2C Sequence)
  S - ADRS W A - [params A...] - Sr - ADRS R A - data_1 A... data_n A|N - [P]
    S : Start condition
    P : Stop condition
    Sr: Repeated start condition
    A : Ack
    N : Nack
*/
static void c_i2c_read(struct VM *vm, mrb_value v[], int argc)
{
  struct I2C_attr *attr = (struct I2C_attr *)v->instance->data;
  uint32_t status = 0;
  mrb_value ret = mrb_nil_value();

  /*
    Get parameter
  */
  int i2c_adrs_7;
  int read_bytes;
  uint8_t *buf = 0;
  int flag_no_stop;
  int flag_params;

  if( argc < 2 ) goto ERROR_PARAM;
  if( v[1].tt != MRBC_TT_FIXNUM ) goto ERROR_PARAM;
  i2c_adrs_7 = GET_INT_ARG(1);

  if( v[2].tt != MRBC_TT_FIXNUM ) goto ERROR_PARAM;
  read_bytes = GET_INT_ARG(2);

  flag_no_stop = (v[argc].tt == MRBC_TT_SYMBOL && v[argc].i == str_to_symid("NO_STOP"));
  flag_params = (argc - 2 - flag_no_stop) > 0;

  /* start condition check.
     - - - -  - - 1 0
                  | \_ bit 0: send start or restart condition flag.
                   \__ bit 1: address check result.
  */
  int start_cond_case = (attr->address == i2c_adrs_7) << 1 |
                        (attr->state == I2C_STATE_READ2);
  attr->state = I2C_STATE_READ1;
  attr->address = i2c_adrs_7;

  /*
    Start I2C communication
  */
  // send START condition, slave address and R/W (1:read, 0:write)
  switch( start_cond_case ) {
  case 0x00:
    I2CNAME_MasterClearStatus();
    status = I2CNAME_MasterSendStart( i2c_adrs_7, !flag_params );
    if( status != I2CNAME_MSTR_NO_ERROR ) goto ERROR;
    break;

  case 0x02:
    status = I2CNAME_MasterSendRestart( i2c_adrs_7, !flag_params );
    if( status != I2CNAME_MSTR_NO_ERROR ) goto ERROR;
    break;

  case 0x01:
    goto ERROR_PARAM;

  case 0x03:
  default:
    ;
  }

  // send params if specified.
  if( flag_params ) {
    for( int i = 3; i <= (argc - flag_no_stop); i++ ) {
      if( v[i].tt != MRBC_TT_FIXNUM ) goto ERROR_PARAM;
      status = I2CNAME_MasterWriteByte( v[i].i );
      if( status != I2CNAME_MSTR_NO_ERROR ) goto ERROR;
    }
    if( read_bytes <= 0 ) goto DONE;

    // send repeated start
    status = I2CNAME_MasterSendRestart( i2c_adrs_7, 1 );	// 1:read
    if( status != I2CNAME_MSTR_NO_ERROR ) goto ERROR;
  }

  // receive data.
  attr->state = I2C_STATE_READ2;
  buf = mrbc_alloc(vm, read_bytes + 1);
  if( !buf ) goto ERROR;
  uint8_t *p_buf = buf;
  for( int i = read_bytes - !flag_no_stop; i > 0; i-- ) {
    *p_buf++ = I2CNAME_MasterReadByte( I2CNAME_ACK_DATA );
  }
  if( !flag_no_stop && read_bytes > 0 ) {
    *p_buf++ = I2CNAME_MasterReadByte( I2CNAME_NAK_DATA );
  }
  *p_buf = 0;
  ret = mrbc_string_new_alloc(vm, buf, read_bytes);

  if( flag_no_stop ) goto DONE;

  // send STOP condition.
  status = I2CNAME_MasterSendStop();
  attr->state = I2C_STATE_NONE;
  attr->address = -1;
  goto DONE;


 ERROR_PARAM:
  console_printf("i2c_read: parameter error.\n");

 ERROR:
  I2CNAME_MasterSendStop();
  attr->state = I2C_STATE_NONE;
  attr->address = -1;
  if( buf ) mrbc_raw_free(buf);

 DONE:
  attr->status = status;

  SET_RETURN( ret );
}


//================================================================
/*! I2C write

  (mruby usage)
  i2c.write( i2c_adrs_7, write_data, ..., [:NO_STOP] )

  i2c_adrs_7 = Fixnum
  write_data = String, or Fixnum...
  :NO_STOP  if you don't need stop conditon, specify :NO_STOP

  (I2C Sequence)
  S - ADRS W A - data1 A... - [P]

    S : Start condition
    P : Stop condition
    A : Ack
*/
static void c_i2c_write(struct VM *vm, mrb_value v[], int argc)
{
  struct I2C_attr *attr = (struct I2C_attr *)v->instance->data;
  uint32_t status = 0;

  /*
    Get parameter
  */
  int i2c_adrs_7;
  int write_bytes;
  const char *write_ptr = 0;
  int flag_no_stop;

  if( argc < 1 ) goto ERROR_PARAM;
  if( v[1].tt != MRBC_TT_FIXNUM ) goto ERROR_PARAM;
  i2c_adrs_7 = GET_INT_ARG(1);

  flag_no_stop = (v[argc].tt == MRBC_TT_SYMBOL && v[argc].i == str_to_symid("NO_STOP"));

  if( argc >= 2 && v[2].tt == MRBC_TT_STRING ) {
    write_bytes = mrbc_string_size( &GET_ARG(2) );
    write_ptr = mrbc_string_cstr( &GET_ARG(2) );
  } else {
    write_bytes = argc - flag_no_stop - 1;
  }

  /* start condition check.
     - - - -  - - 1 0
                  | \_ bit 0: send start or restart condition flag.
                   \__ bit 1: address check result.
  */
  int start_cond_case = (attr->address == i2c_adrs_7) << 1 |
                        (attr->state == I2C_STATE_WRITE);
  attr->state = I2C_STATE_WRITE;
  attr->address = i2c_adrs_7;

  /*
    Start I2C communication
  */
  // send START condition, slave address and R/W (0:write)
  switch( start_cond_case ) {
  case 0x00:
    I2CNAME_MasterClearStatus();
    status = I2CNAME_MasterSendStart( i2c_adrs_7, 0 );
    if( status != I2CNAME_MSTR_NO_ERROR ) goto ERROR;
    break;

  case 0x02:
    status = I2CNAME_MasterSendRestart( i2c_adrs_7, 0 );
    if( status != I2CNAME_MSTR_NO_ERROR ) goto ERROR;
    break;

  case 0x01:
    goto ERROR_PARAM;

  case 0x03:
  default:
    ;
  }

  // send data.
  for( int i = 0; i < write_bytes; i++ ) {
    if( write_ptr ) {
      status = I2CNAME_MasterWriteByte( *write_ptr++ );
    } else {
      if( v[i+2].tt != MRBC_TT_FIXNUM ) goto ERROR_PARAM;
      status = I2CNAME_MasterWriteByte( v[i+2].i );
    }
    if( status != I2CNAME_MSTR_NO_ERROR ) goto ERROR;
  }

  if( flag_no_stop ) goto DONE;

  // send STOP condition.
  status = I2CNAME_MasterSendStop();
  attr->state = I2C_STATE_NONE;
  attr->address = -1;
  goto DONE;


 ERROR_PARAM:
  console_printf("i2c.write: parameter error.\n");

 ERROR:
  I2CNAME_MasterSendStop();
  attr->state = I2C_STATE_NONE;
  attr->address = -1;

 DONE:
  attr->status = status;

  SET_INT_RETURN(status);
}



//================================================================
/*! initialize
*/
void mrbc_init_class_i2c(struct VM *vm)
{
  I2CNAME_Start();	// start physical device

  mrb_class *i2c;
  i2c = mrbc_define_class(vm, "I2C",	mrbc_class_object);

  mrbc_define_method(vm, i2c, "new",	c_i2c_new);
  mrbc_define_method(vm, i2c, "read",	c_i2c_read);
  mrbc_define_method(vm, i2c, "write",	c_i2c_write);
  mrbc_define_method(vm, i2c, "status",	c_i2c_status);
  mrbc_define_method(vm, i2c, "clear_status", c_i2c_clear_status);
}
