/*! @file
  @brief
  SPI class for Cypress PSoC5LP

  <pre>
  Copyright (C) 2019 Kyushu Institute of Technology.
  Copyright (C) 2019 Shimane IT Open-Innovation Center.

  This file is distributed under BSD 3-Clause License.

  (Usage)
  Hardware configration.

   1. Use PSoC Creator, place "Communication > SPI >
        SPI Master Full Duplex mode Macro" device.
   2. Open a configure dialog.
   3. Make sure the name is "SPIM_1".
   4. Set the Mode, Shift Direction, and Bit Rate.
   5. Change to the "Advanced" tab and check as follows.
	Enable Tx Internal Interrupt
	Interrupt On Byte/Word Transfer Complete
	Enable Rx Internal Interrupt
	Interrupt On Rx FIFO Not Empty

   6. Close this dialog.
   7. Place "Ports and Pins > Digital Output Pin"
   8. Connect to SPIM_1's ss pin.
   9. Add following lines to the auto-generated "cyapicallbacks.h".
	#define SPIM_1_TX_ISR_ENTRY_CALLBACK
	void SPIM_1_TX_ISR_EntryCallback(void);
	#define SPIM_1_RX_ISR_ENTRY_CALLBACK
	void SPIM_1_RX_ISR_EntryCallback(void);

  More SPI devices?
      Place the following SPI device and the Digital Output Pin connected to ss,
      and add the interrupt setting to “cyapicallbacks.h”.
      Define pre-processor macro MRBC_NUM_SPI=n. (n=1..3)


  C program (main.c)
    #include "c_spi.h"
    mrbc_init_class_spi(0);


  mruby program

    # create object
    spi = SPI.new()	# first device
    spi = SPI.new(1)	# first device
    spi = SPI.new(2)	# secound device

    # transfer (normally used)
    #  sending 0xf2 and then send 0x00 * 6bytes.
    #  receive 7 bytes but returns the last 6 bytes.
    ret = spi.transfer( [0xf2], 6 )

    # only write
    #  send 2 bytes of 0x2c and 0x0a.
    spi.write( 0x2c, 0x0a )

    # only read
    #  sending 0x00 * 2 bytes, then receive 2 bytes and return.
    ret = spi.read( 2 )
  </pre>
*/


#include "vm_config.h"
#include <stdint.h>
#include <project.h>	// auto generated by PSoC Creator.

#include "value.h"
#include "alloc.h"
#include "static.h"
#include "class.h"
#include "vm.h"
#include "c_string.h"
#include "c_array.h"

#include "spi_m2.h"


//================================================================
/*! SPI用設定
*/
#if !defined(MRBC_NUM_SPI)
# define MRBC_NUM_SPI 1
#endif

static SPI_HANDLE spih[MRBC_NUM_SPI];

#if MRBC_NUM_SPI >= 1	// use boost? the following are enough in this project.
SPI_ISR( &spih[0], SPIM_1 );
#endif
#if MRBC_NUM_SPI >= 2
SPI_ISR( &spih[1], SPIM_2 );
#endif
#if MRBC_NUM_SPI >= 3
SPI_ISR( &spih[2], SPIM_3 );
#endif
#if MRBC_NUM_SPI >= 4
#error "MRBC_NUM_SPI >= 4"
#endif



//================================================================
/*! SPI constructor

  $spi = SPI.new	# first interface
  $spi = SPI.new( num )	# specifies interface number. 1 origin.
*/
static void c_spi_new(mrbc_vm *vm, mrbc_value v[], int argc)
{
  int spi_num;

  if( argc == 0 ) {
    spi_num = 0;
  } else if( v[1].tt == MRBC_TT_FIXNUM ) {
    spi_num = v[1].i - 1;
  } else {
    goto ERROR_RETURN;
  }
  if( spi_num < 0 || spi_num >= MRBC_NUM_SPI ) goto ERROR_RETURN;

  *v = mrbc_instance_new(vm, v->cls, sizeof(SPI_HANDLE *));
  *((SPI_HANDLE **)v->instance->data) = &spih[spi_num];
  return;

 ERROR_RETURN:
  SET_NIL_RETURN();
}


//================================================================
/*! read

  s = $spi.read(n)

  @param  n		Number of bytes receive.
  @return String	Received data.
*/
static void c_spi_read(mrbc_vm *vm, mrbc_value v[], int argc)
{
  mrbc_value ret;
  SPI_HANDLE *handle = *(SPI_HANDLE **)v->instance->data;
  int recv_len = GET_INT_ARG(1);
  uint8_t *buf = mrbc_alloc( vm, recv_len+1 );
  if( !buf ) {			// ENOMEM
    ret = mrbc_nil_value();
    goto DONE;
  }

  spi_transfer(handle, 0, 0, buf, recv_len, 0);
  spi_wait_done( handle );
  buf[recv_len] = 0;
  ret = mrbc_string_new_alloc( vm, buf, recv_len );

 DONE:
  SET_RETURN(ret);
}


//================================================================
/*! write

  $spi.write( str )
  $spi.write( d1, d2, ...)
*/
static void c_spi_write(mrbc_vm *vm, mrbc_value v[], int argc)
{
  SPI_HANDLE *handle = *(SPI_HANDLE **)v->instance->data;

  if( v[1].tt == MRBC_TT_STRING ) {
    spi_transfer( handle, mrbc_string_cstr(&v[1]), mrbc_string_size(&v[1]),
		  0, 0, 0 );
    spi_wait_done( handle );
    goto DONE;
  }


  if( v[1].tt == MRBC_TT_FIXNUM ) {
    uint8_t *buf = mrbc_raw_alloc( argc );
    if( !buf ) goto DONE;	// ENOMEM
    int i;
    for( i = 0; i < argc; i++ ) {
      buf[i] = GET_INT_ARG(i+1);
    }
    spi_transfer( handle, buf, argc, 0, 0, 0 );
    spi_wait_done( handle );
    mrbc_raw_free( buf );
    goto DONE;
  }

  // else TypeError. raise?


 DONE:
  SET_NIL_RETURN();
}


//================================================================
/*! transfer

  $spi.transfer( s, recv_size )
  $spi.transfer( [d1, d2,...], recv_size )

  @return String	Received data.
*/
static void c_spi_transfer(mrbc_vm *vm, mrbc_value v[], int argc)
{
  mrbc_value ret;
  SPI_HANDLE *handle = *(SPI_HANDLE **)v->instance->data;

  if( v[1].tt == MRBC_TT_STRING && v[2].tt == MRBC_TT_FIXNUM ) {
    int recv_len = GET_INT_ARG(2);
    uint8_t *buf = mrbc_alloc( vm, recv_len+1 );
    if( !buf ) goto ERROR_RETURN;		// ENOMEM
    spi_transfer( handle, mrbc_string_cstr(&v[1]), mrbc_string_size(&v[1]),
		  buf, recv_len, 0 );
    spi_wait_done( handle );
    buf[recv_len] = 0;
    ret = mrbc_string_new_alloc( vm, buf, recv_len );
    goto DONE;
  }


  if( v[1].tt == MRBC_TT_ARRAY && v[2].tt == MRBC_TT_FIXNUM ) {
    int send_len = mrbc_array_size( &v[1] );
    int recv_len = GET_INT_ARG(2);
    uint8_t *buf = mrbc_raw_alloc( send_len > recv_len ? send_len : recv_len );
    if( !buf ) goto ERROR_RETURN;		// ENOMEM

    int i;
    for( i = 0; i < send_len; i++ ) {
      mrbc_value v1 = mrbc_array_get( &v[1], i );
      if( v1.tt != MRBC_TT_FIXNUM ) {		// TypeError. raise?
	mrbc_raw_free( buf );
	goto ERROR_RETURN;
      }
      buf[i] = v1.i;
    }

    spi_transfer( handle, buf, send_len, buf, recv_len, 0 );
    spi_wait_done( handle );
    buf[recv_len] = 0;
    ret = mrbc_string_new_alloc( vm, buf, recv_len );
    goto DONE;
  }

  // else TypeError. raise?


 ERROR_RETURN:
  ret = mrbc_nil_value();

 DONE:
  SET_RETURN(ret);
}



//================================================================
/*! initialize
*/
void mrbc_init_class_spi(struct VM *vm)
{
  // start physical device
#if MRBC_NUM_SPI >= 1
  spi_init( &spih[0], SPIM_1 );
#endif
#if MRBC_NUM_SPI >= 2
  spi_init( &spih[1], SPIM_2 );
#endif
#if MRBC_NUM_SPI >= 3
  spi_init( &spih[2], SPIM_3 );
#endif

  // define class and methods.
  mrbc_class *spi;
  spi = mrbc_define_class(0, "SPI",	mrbc_class_object);
  mrbc_define_method(0, spi, "new",	c_spi_new);
  mrbc_define_method(0, spi, "read",	c_spi_read);
  mrbc_define_method(0, spi, "write",	c_spi_write);
  mrbc_define_method(0, spi, "transfer",c_spi_transfer);
}
