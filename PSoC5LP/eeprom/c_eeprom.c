/*! @file
  @brief
  EEPROM class for Cypress PSoC5LP

  <pre>
  Copyright (C) 2020 Kyushu Institute of Technology.
  Copyright (C) 2020 Shimane IT Open-Innovation Center.

  This file is distributed under BSD 3-Clause License.

  (Usage)
   1. Launch PSoC Creator.
   2. Place 'EEPROM' device.
   3. Make sure name is 'EEPROM_1'.
   4. Copy c_eeprom.h and c_eeprom.c files to project folder.
   5. Add this (c_eeprom.c) file to PSoC Creator.
   6. Add below to main.c.
      #include "c_eeprom.h"
      mrbc_init_class_eeprom(0);	// needs to be after mrbc_init()


  (on Ruby)
    # write to device
    EEPROM.write( address, "DATA" )

    # read from device
    s = EEPROM.read( address, byte_length )

  (note)
    Only string read/write available in this version.
    Address range is 0 to 2047.

  </pre>
*/


#include "vm_config.h"
#include <project.h>	// auto generated by PSoC Creator.
#include <stdint.h>
#include <string.h>

#include "mrubyc.h"


//================================================================
/*! EEPROM get size
*/
static void c_eeprom_size(struct VM *vm, mrb_value v[], int argc)
{
  SET_INT_RETURN( CYDEV_EE_SIZE );
}


//================================================================
/*! EEPROM get row size
*/
static void c_eeprom_row_size(struct VM *vm, mrb_value v[], int argc)
{
  SET_INT_RETURN( CYDEV_EEPROM_ROW_SIZE );
}


//================================================================
/*! EEPROM get page size
*/
static void c_eeprom_page_size(struct VM *vm, mrb_value v[], int argc)
{
  SET_INT_RETURN( CYDEV_EEPROM_ROW_SIZE * 64 );
}


//================================================================
/*! EEPROM read

  (mruby usage)
  s = eeprom.read( address, length )  # address = 0 to 2047
*/
static void c_eeprom_read(struct VM *vm, mrb_value v[], int argc)
{
  if( argc < 2 ) goto ERROR_PARAM;
  if( mrbc_type(v[1]) != MRBC_TT_FIXNUM ) goto ERROR_PARAM;
  if( mrbc_type(v[2]) != MRBC_TT_FIXNUM ) goto ERROR_PARAM;

  int address = mrbc_fixnum(v[1]);
  int length = mrbc_fixnum(v[2]);

  uint8_t *buf = mrbc_alloc(vm, length + 1);
  if( !buf ) return;		// ENOMEM, raise?

  memcpy( buf, (uint8_t *)CYDEV_EE_BASE + address, length );
  *(buf + length) = '\0';

  mrbc_value ret = mrbc_string_new_alloc(vm, buf, length);
  SET_RETURN( ret );
  return;

 ERROR_PARAM:
  console_printf("EEPROM: parameter error.\n");
  SET_NIL_RETURN();
}


//================================================================
/*! EEPROM write

  (mruby usage)
  eeprom.write( address, data )
*/
static void c_eeprom_write(struct VM *vm, mrb_value v[], int argc)
{
  if( argc < 2 ) goto ERROR_PARAM;
  if( mrbc_type(v[1]) != MRBC_TT_FIXNUM ) goto ERROR_PARAM;
  if( mrbc_type(v[2]) != MRBC_TT_STRING ) goto ERROR_PARAM;

  int address = mrbc_fixnum(v[1]);
  int remain = mrbc_string_size(&v[2]);
  const uint8_t *p = (uint8_t*)mrbc_string_cstr(&v[2]);

  EEPROM_1_UpdateTemperature();

  // Head surplus
  int len = CYDEV_EEPROM_ROW_SIZE - (address % CYDEV_EEPROM_ROW_SIZE);
  if( len > remain ) len = remain;

  if( len != CYDEV_EEPROM_ROW_SIZE ) {
    remain -= len;
    while( --len >= 0 ) {
      if( EEPROM_1_WriteByte( *p++, address++ ) != CYRET_SUCCESS ) goto ERROR;
    }
  }

  // Just ROW size
  int row_num = address / CYDEV_EEPROM_ROW_SIZE;
  while( remain >= CYDEV_EEPROM_ROW_SIZE ) {
    if( EEPROM_1_Write( p, row_num++ ) != CYRET_SUCCESS ) goto ERROR;

    remain -= CYDEV_EEPROM_ROW_SIZE;
    p += CYDEV_EEPROM_ROW_SIZE;
  }

  // Tail surplus
  address = row_num * CYDEV_EEPROM_ROW_SIZE;
  for(; remain > 0; remain-- ) {
    if( EEPROM_1_WriteByte( *p++, address++ ) != CYRET_SUCCESS ) goto ERROR;
  }

  SET_INT_RETURN(mrbc_string_size(&v[2]));
  return;

 ERROR_PARAM:
  console_printf("EEPROM: parameter error.\n");
  SET_INT_RETURN(0);
  return;

 ERROR:
  console_printf("EEPROM: Write error.\n");
  SET_INT_RETURN(0);
}



//================================================================
/*! initialize
*/
void mrbc_init_class_eeprom(struct VM *vm)
{
  EEPROM_1_Start();	// start physical device

  mrb_class *eeprom;
  eeprom = mrbc_define_class(vm, "EEPROM",	mrbc_class_object);

  mrbc_define_method(vm, eeprom, "size",	c_eeprom_size);
  mrbc_define_method(vm, eeprom, "row_size",	c_eeprom_row_size);
  mrbc_define_method(vm, eeprom, "page_size",	c_eeprom_page_size);
  mrbc_define_method(vm, eeprom, "read",	c_eeprom_read);
  mrbc_define_method(vm, eeprom, "write",	c_eeprom_write);
}
